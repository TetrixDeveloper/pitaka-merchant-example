{"ast":null,"code":"/* eslint-disable */\n\n// return non-nullable if `fragmentType` is non-nullable\n\n// return nullable if `fragmentType` is undefined\n\n// return nullable if `fragmentType` is nullable\n\n// return nullable if `fragmentType` is nullable or undefined\n\n// return array of non-nullable if `fragmentType` is array of non-nullable\n\n// return array of nullable if `fragmentType` is array of nullable\n\n// return readonly array of non-nullable if `fragmentType` is array of non-nullable\n\n// return readonly array of nullable if `fragmentType` is array of nullable\n\nexport function useFragment(_documentNode, fragmentType) {\n  return fragmentType;\n}\nexport function makeFragmentData(data, _fragment) {\n  return data;\n}\nexport function isFragmentReady(queryNode, fragmentNode, data) {\n  var _meta__, _fragDef$name;\n  const deferredFields = (_meta__ = queryNode.__meta__) === null || _meta__ === void 0 ? void 0 : _meta__.deferredFields;\n  if (!deferredFields) return true;\n  const fragDef = fragmentNode.definitions[0];\n  const fragName = fragDef === null || fragDef === void 0 ? void 0 : (_fragDef$name = fragDef.name) === null || _fragDef$name === void 0 ? void 0 : _fragDef$name.value;\n  const fields = fragName && deferredFields[fragName] || [];\n  return fields.length > 0 && fields.every(field => data && field in data);\n}","map":{"version":3,"names":["useFragment","_documentNode","fragmentType","makeFragmentData","data","_fragment","isFragmentReady","queryNode","fragmentNode","_meta__","_fragDef$name","deferredFields","__meta__","fragDef","definitions","fragName","name","value","fields","length","every","field"],"sources":["C:/Users/iandev/Documents/GitHub/pitaka-merchant-example/src/__generated__/gql/fragment-masking.ts"],"sourcesContent":["/* eslint-disable */\r\nimport { ResultOf, DocumentTypeDecoration, TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { FragmentDefinitionNode } from 'graphql';\r\nimport { Incremental } from './graphql';\r\n\r\n\r\nexport type FragmentType<TDocumentType extends DocumentTypeDecoration<any, any>> = TDocumentType extends DocumentTypeDecoration<\r\n  infer TType,\r\n  any\r\n>\r\n  ? [TType] extends [{ ' $fragmentName'?: infer TKey }]\r\n    ? TKey extends string\r\n      ? { ' $fragmentRefs'?: { [key in TKey]: TType } }\r\n      : never\r\n    : never\r\n  : never;\r\n\r\n// return non-nullable if `fragmentType` is non-nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>>\r\n): TType;\r\n// return nullable if `fragmentType` is undefined\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | undefined\r\n): TType | undefined;\r\n// return nullable if `fragmentType` is nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | null\r\n): TType | null;\r\n// return nullable if `fragmentType` is nullable or undefined\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | null | undefined\r\n): TType | null | undefined;\r\n// return array of non-nullable if `fragmentType` is array of non-nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: Array<FragmentType<DocumentTypeDecoration<TType, any>>>\r\n): Array<TType>;\r\n// return array of nullable if `fragmentType` is array of nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: Array<FragmentType<DocumentTypeDecoration<TType, any>>> | null | undefined\r\n): Array<TType> | null | undefined;\r\n// return readonly array of non-nullable if `fragmentType` is array of non-nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>>\r\n): ReadonlyArray<TType>;\r\n// return readonly array of nullable if `fragmentType` is array of nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>> | null | undefined\r\n): ReadonlyArray<TType> | null | undefined;\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | Array<FragmentType<DocumentTypeDecoration<TType, any>>> | ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>> | null | undefined\r\n): TType | Array<TType> | ReadonlyArray<TType> | null | undefined {\r\n  return fragmentType as any;\r\n}\r\n\r\n\r\nexport function makeFragmentData<\r\n  F extends DocumentTypeDecoration<any, any>,\r\n  FT extends ResultOf<F>\r\n>(data: FT, _fragment: F): FragmentType<F> {\r\n  return data as FragmentType<F>;\r\n}\r\nexport function isFragmentReady<TQuery, TFrag>(\r\n  queryNode: DocumentTypeDecoration<TQuery, any>,\r\n  fragmentNode: TypedDocumentNode<TFrag>,\r\n  data: FragmentType<TypedDocumentNode<Incremental<TFrag>, any>> | null | undefined\r\n): data is FragmentType<typeof fragmentNode> {\r\n  const deferredFields = (queryNode as { __meta__?: { deferredFields: Record<string, (keyof TFrag)[]> } }).__meta__\r\n    ?.deferredFields;\r\n\r\n  if (!deferredFields) return true;\r\n\r\n  const fragDef = fragmentNode.definitions[0] as FragmentDefinitionNode | undefined;\r\n  const fragName = fragDef?.name?.value;\r\n\r\n  const fields = (fragName && deferredFields[fragName]) || [];\r\n  return fields.length > 0 && fields.every(field => data && field in data);\r\n}\r\n"],"mappings":"AAAA;;AAiBA;;AAKA;;AAKA;;AAKA;;AAKA;;AAKA;;AAKA;;AAKA;;AAKA,OAAO,SAASA,WAAWA,CACzBC,aAAiD,EACjDC,YAA6M,EAC7I;EAChE,OAAOA,YAAY;AACrB;AAGA,OAAO,SAASC,gBAAgBA,CAG9BC,IAAQ,EAAEC,SAAY,EAAmB;EACzC,OAAOD,IAAI;AACb;AACA,OAAO,SAASE,eAAeA,CAC7BC,SAA8C,EAC9CC,YAAsC,EACtCJ,IAAiF,EACtC;EAAA,IAAAK,OAAA,EAAAC,aAAA;EAC3C,MAAMC,cAAc,IAAAF,OAAA,GAAIF,SAAS,CAAwEK,QAAQ,cAAAH,OAAA,uBAA1FA,OAAA,CACnBE,cAAc;EAElB,IAAI,CAACA,cAAc,EAAE,OAAO,IAAI;EAEhC,MAAME,OAAO,GAAGL,YAAY,CAACM,WAAW,CAAC,CAAC,CAAuC;EACjF,MAAMC,QAAQ,GAAGF,OAAO,aAAPA,OAAO,wBAAAH,aAAA,GAAPG,OAAO,CAAEG,IAAI,cAAAN,aAAA,uBAAbA,aAAA,CAAeO,KAAK;EAErC,MAAMC,MAAM,GAAIH,QAAQ,IAAIJ,cAAc,CAACI,QAAQ,CAAC,IAAK,EAAE;EAC3D,OAAOG,MAAM,CAACC,MAAM,GAAG,CAAC,IAAID,MAAM,CAACE,KAAK,CAACC,KAAK,IAAIjB,IAAI,IAAIiB,KAAK,IAAIjB,IAAI,CAAC;AAC1E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}