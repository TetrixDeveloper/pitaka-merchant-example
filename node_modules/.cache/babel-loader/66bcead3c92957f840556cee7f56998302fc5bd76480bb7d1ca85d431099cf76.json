{"ast":null,"code":"/* eslint-disable */\n\n// return non-nullable if `fragmentType` is non-nullable\n\n// return nullable if `fragmentType` is undefined\n\n// return nullable if `fragmentType` is nullable\n\n// return nullable if `fragmentType` is nullable or undefined\n\n// return array of non-nullable if `fragmentType` is array of non-nullable\n\n// return array of nullable if `fragmentType` is array of nullable\n\n// return readonly array of non-nullable if `fragmentType` is array of non-nullable\n\n// return readonly array of nullable if `fragmentType` is array of nullable\n\nexport function useFragment(_documentNode, fragmentType) {\n  return fragmentType;\n}\nexport function makeFragmentData(data, _fragment) {\n  return data;\n}\nexport function isFragmentReady(queryNode, fragmentNode, data) {\n  var _meta__, _fragDef$name;\n  const deferredFields = (_meta__ = queryNode.__meta__) === null || _meta__ === void 0 ? void 0 : _meta__.deferredFields;\n  if (!deferredFields) return true;\n  const fragDef = fragmentNode.definitions[0];\n  const fragName = fragDef === null || fragDef === void 0 ? void 0 : (_fragDef$name = fragDef.name) === null || _fragDef$name === void 0 ? void 0 : _fragDef$name.value;\n  const fields = fragName && deferredFields[fragName] || [];\n  return fields.length > 0 && fields.every(field => data && field in data);\n}","map":{"version":3,"names":["useFragment","_documentNode","fragmentType","makeFragmentData","data","_fragment","isFragmentReady","queryNode","fragmentNode","_meta__","_fragDef$name","deferredFields","__meta__","fragDef","definitions","fragName","name","value","fields","length","every","field"],"sources":["C:/Users/iandev/Documents/GitHub/pitaka-merchant-example/src/__generated__/gql/fragment-masking.ts"],"sourcesContent":["/* eslint-disable */\r\nimport {\r\n  ResultOf,\r\n  DocumentTypeDecoration,\r\n  TypedDocumentNode,\r\n} from '@graphql-typed-document-node/core';\r\nimport { FragmentDefinitionNode } from 'graphql';\r\nimport { Incremental } from './graphql';\r\n\r\nexport type FragmentType<\r\n  TDocumentType extends DocumentTypeDecoration<any, any>,\r\n> =\r\n  TDocumentType extends DocumentTypeDecoration<infer TType, any>\r\n    ? [TType] extends [{ ' $fragmentName'?: infer TKey }]\r\n      ? TKey extends string\r\n        ? { ' $fragmentRefs'?: { [key in TKey]: TType } }\r\n        : never\r\n      : never\r\n    : never;\r\n\r\n// return non-nullable if `fragmentType` is non-nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>>\r\n): TType;\r\n// return nullable if `fragmentType` is undefined\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | undefined\r\n): TType | undefined;\r\n// return nullable if `fragmentType` is nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | null\r\n): TType | null;\r\n// return nullable if `fragmentType` is nullable or undefined\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType:\r\n    | FragmentType<DocumentTypeDecoration<TType, any>>\r\n    | null\r\n    | undefined\r\n): TType | null | undefined;\r\n// return array of non-nullable if `fragmentType` is array of non-nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: Array<FragmentType<DocumentTypeDecoration<TType, any>>>\r\n): Array<TType>;\r\n// return array of nullable if `fragmentType` is array of nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType:\r\n    | Array<FragmentType<DocumentTypeDecoration<TType, any>>>\r\n    | null\r\n    | undefined\r\n): Array<TType> | null | undefined;\r\n// return readonly array of non-nullable if `fragmentType` is array of non-nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType: ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>>\r\n): ReadonlyArray<TType>;\r\n// return readonly array of nullable if `fragmentType` is array of nullable\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType:\r\n    | ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>>\r\n    | null\r\n    | undefined\r\n): ReadonlyArray<TType> | null | undefined;\r\nexport function useFragment<TType>(\r\n  _documentNode: DocumentTypeDecoration<TType, any>,\r\n  fragmentType:\r\n    | FragmentType<DocumentTypeDecoration<TType, any>>\r\n    | Array<FragmentType<DocumentTypeDecoration<TType, any>>>\r\n    | ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>>\r\n    | null\r\n    | undefined\r\n): TType | Array<TType> | ReadonlyArray<TType> | null | undefined {\r\n  return fragmentType as any;\r\n}\r\n\r\nexport function makeFragmentData<\r\n  F extends DocumentTypeDecoration<any, any>,\r\n  FT extends ResultOf<F>,\r\n>(data: FT, _fragment: F): FragmentType<F> {\r\n  return data as FragmentType<F>;\r\n}\r\nexport function isFragmentReady<TQuery, TFrag>(\r\n  queryNode: DocumentTypeDecoration<TQuery, any>,\r\n  fragmentNode: TypedDocumentNode<TFrag>,\r\n  data:\r\n    | FragmentType<TypedDocumentNode<Incremental<TFrag>, any>>\r\n    | null\r\n    | undefined\r\n): data is FragmentType<typeof fragmentNode> {\r\n  const deferredFields = (\r\n    queryNode as {\r\n      __meta__?: { deferredFields: Record<string, (keyof TFrag)[]> };\r\n    }\r\n  ).__meta__?.deferredFields;\r\n\r\n  if (!deferredFields) return true;\r\n\r\n  const fragDef = fragmentNode.definitions[0] as\r\n    | FragmentDefinitionNode\r\n    | undefined;\r\n  const fragName = fragDef?.name?.value;\r\n\r\n  const fields = (fragName && deferredFields[fragName]) || [];\r\n  return fields.length > 0 && fields.every((field) => data && field in data);\r\n}\r\n"],"mappings":"AAAA;;AAoBA;;AAKA;;AAKA;;AAKA;;AAQA;;AAKA;;AAQA;;AAKA;;AAQA,OAAO,SAASA,WAAWA,CACzBC,aAAiD,EACjDC,YAKa,EACmD;EAChE,OAAOA,YAAY;AACrB;AAEA,OAAO,SAASC,gBAAgBA,CAG9BC,IAAQ,EAAEC,SAAY,EAAmB;EACzC,OAAOD,IAAI;AACb;AACA,OAAO,SAASE,eAAeA,CAC7BC,SAA8C,EAC9CC,YAAsC,EACtCJ,IAGa,EAC8B;EAAA,IAAAK,OAAA,EAAAC,aAAA;EAC3C,MAAMC,cAAc,IAAAF,OAAA,GAClBF,SAAS,CAGTK,QAAQ,cAAAH,OAAA,uBAJaA,OAAA,CAIXE,cAAc;EAE1B,IAAI,CAACA,cAAc,EAAE,OAAO,IAAI;EAEhC,MAAME,OAAO,GAAGL,YAAY,CAACM,WAAW,CAAC,CAAC,CAE7B;EACb,MAAMC,QAAQ,GAAGF,OAAO,aAAPA,OAAO,wBAAAH,aAAA,GAAPG,OAAO,CAAEG,IAAI,cAAAN,aAAA,uBAAbA,aAAA,CAAeO,KAAK;EAErC,MAAMC,MAAM,GAAIH,QAAQ,IAAIJ,cAAc,CAACI,QAAQ,CAAC,IAAK,EAAE;EAC3D,OAAOG,MAAM,CAACC,MAAM,GAAG,CAAC,IAAID,MAAM,CAACE,KAAK,CAAEC,KAAK,IAAKjB,IAAI,IAAIiB,KAAK,IAAIjB,IAAI,CAAC;AAC5E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}