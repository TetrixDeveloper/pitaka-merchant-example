{"ast":null,"code":"/* eslint-disable */\n\n// return non-nullable if `fragmentType` is non-nullable\n\n// return nullable if `fragmentType` is undefined\n\n// return nullable if `fragmentType` is nullable\n\n// return nullable if `fragmentType` is nullable or undefined\n\n// return array of non-nullable if `fragmentType` is array of non-nullable\n\n// return array of nullable if `fragmentType` is array of nullable\n\n// return readonly array of non-nullable if `fragmentType` is array of non-nullable\n\n// return readonly array of nullable if `fragmentType` is array of nullable\n\nexport function useFragment(_documentNode, fragmentType) {\n  return fragmentType;\n}\nexport function makeFragmentData(data, _fragment) {\n  return data;\n}\nexport function isFragmentReady(queryNode, fragmentNode, data) {\n  var _meta__, _fragDef$name;\n  const deferredFields = (_meta__ = queryNode.__meta__) === null || _meta__ === void 0 ? void 0 : _meta__.deferredFields;\n  if (!deferredFields) return true;\n  const fragDef = fragmentNode.definitions[0];\n  const fragName = fragDef === null || fragDef === void 0 ? void 0 : (_fragDef$name = fragDef.name) === null || _fragDef$name === void 0 ? void 0 : _fragDef$name.value;\n  const fields = fragName && deferredFields[fragName] || [];\n  return fields.length > 0 && fields.every(field => data && field in data);\n}","map":{"version":3,"names":["useFragment","_documentNode","fragmentType","makeFragmentData","data","_fragment","isFragmentReady","queryNode","fragmentNode","_meta__","_fragDef$name","deferredFields","__meta__","fragDef","definitions","fragName","name","value","fields","length","every","field"],"sources":["C:/Users/iandev/Documents/GitHub/pitaka-merchant-example/src/__generated__/gql/fragment-masking.ts"],"sourcesContent":["/* eslint-disable */\nimport {\n  ResultOf,\n  DocumentTypeDecoration,\n  TypedDocumentNode,\n} from '@graphql-typed-document-node/core';\nimport { FragmentDefinitionNode } from 'graphql';\nimport { Incremental } from './graphql';\n\nexport type FragmentType<\n  TDocumentType extends DocumentTypeDecoration<any, any>,\n> =\n  TDocumentType extends DocumentTypeDecoration<infer TType, any>\n    ? [TType] extends [{ ' $fragmentName'?: infer TKey }]\n      ? TKey extends string\n        ? { ' $fragmentRefs'?: { [key in TKey]: TType } }\n        : never\n      : never\n    : never;\n\n// return non-nullable if `fragmentType` is non-nullable\nexport function useFragment<TType>(\n  _documentNode: DocumentTypeDecoration<TType, any>,\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>>\n): TType;\n// return nullable if `fragmentType` is undefined\nexport function useFragment<TType>(\n  _documentNode: DocumentTypeDecoration<TType, any>,\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | undefined\n): TType | undefined;\n// return nullable if `fragmentType` is nullable\nexport function useFragment<TType>(\n  _documentNode: DocumentTypeDecoration<TType, any>,\n  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | null\n): TType | null;\n// return nullable if `fragmentType` is nullable or undefined\nexport function useFragment<TType>(\n  _documentNode: DocumentTypeDecoration<TType, any>,\n  fragmentType:\n    | FragmentType<DocumentTypeDecoration<TType, any>>\n    | null\n    | undefined\n): TType | null | undefined;\n// return array of non-nullable if `fragmentType` is array of non-nullable\nexport function useFragment<TType>(\n  _documentNode: DocumentTypeDecoration<TType, any>,\n  fragmentType: Array<FragmentType<DocumentTypeDecoration<TType, any>>>\n): Array<TType>;\n// return array of nullable if `fragmentType` is array of nullable\nexport function useFragment<TType>(\n  _documentNode: DocumentTypeDecoration<TType, any>,\n  fragmentType:\n    | Array<FragmentType<DocumentTypeDecoration<TType, any>>>\n    | null\n    | undefined\n): Array<TType> | null | undefined;\n// return readonly array of non-nullable if `fragmentType` is array of non-nullable\nexport function useFragment<TType>(\n  _documentNode: DocumentTypeDecoration<TType, any>,\n  fragmentType: ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>>\n): ReadonlyArray<TType>;\n// return readonly array of nullable if `fragmentType` is array of nullable\nexport function useFragment<TType>(\n  _documentNode: DocumentTypeDecoration<TType, any>,\n  fragmentType:\n    | ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>>\n    | null\n    | undefined\n): ReadonlyArray<TType> | null | undefined;\nexport function useFragment<TType>(\n  _documentNode: DocumentTypeDecoration<TType, any>,\n  fragmentType:\n    | FragmentType<DocumentTypeDecoration<TType, any>>\n    | Array<FragmentType<DocumentTypeDecoration<TType, any>>>\n    | ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>>\n    | null\n    | undefined\n): TType | Array<TType> | ReadonlyArray<TType> | null | undefined {\n  return fragmentType as any;\n}\n\nexport function makeFragmentData<\n  F extends DocumentTypeDecoration<any, any>,\n  FT extends ResultOf<F>,\n>(data: FT, _fragment: F): FragmentType<F> {\n  return data as FragmentType<F>;\n}\nexport function isFragmentReady<TQuery, TFrag>(\n  queryNode: DocumentTypeDecoration<TQuery, any>,\n  fragmentNode: TypedDocumentNode<TFrag>,\n  data:\n    | FragmentType<TypedDocumentNode<Incremental<TFrag>, any>>\n    | null\n    | undefined\n): data is FragmentType<typeof fragmentNode> {\n  const deferredFields = (\n    queryNode as {\n      __meta__?: { deferredFields: Record<string, (keyof TFrag)[]> };\n    }\n  ).__meta__?.deferredFields;\n\n  if (!deferredFields) return true;\n\n  const fragDef = fragmentNode.definitions[0] as\n    | FragmentDefinitionNode\n    | undefined;\n  const fragName = fragDef?.name?.value;\n\n  const fields = (fragName && deferredFields[fragName]) || [];\n  return fields.length > 0 && fields.every((field) => data && field in data);\n}\n"],"mappings":"AAAA;;AAoBA;;AAKA;;AAKA;;AAKA;;AAQA;;AAKA;;AAQA;;AAKA;;AAQA,OAAO,SAASA,WAAWA,CACzBC,aAAiD,EACjDC,YAKa,EACmD;EAChE,OAAOA,YAAY;AACrB;AAEA,OAAO,SAASC,gBAAgBA,CAG9BC,IAAQ,EAAEC,SAAY,EAAmB;EACzC,OAAOD,IAAI;AACb;AACA,OAAO,SAASE,eAAeA,CAC7BC,SAA8C,EAC9CC,YAAsC,EACtCJ,IAGa,EAC8B;EAAA,IAAAK,OAAA,EAAAC,aAAA;EAC3C,MAAMC,cAAc,IAAAF,OAAA,GAClBF,SAAS,CAGTK,QAAQ,cAAAH,OAAA,uBAJaA,OAAA,CAIXE,cAAc;EAE1B,IAAI,CAACA,cAAc,EAAE,OAAO,IAAI;EAEhC,MAAME,OAAO,GAAGL,YAAY,CAACM,WAAW,CAAC,CAAC,CAE7B;EACb,MAAMC,QAAQ,GAAGF,OAAO,aAAPA,OAAO,wBAAAH,aAAA,GAAPG,OAAO,CAAEG,IAAI,cAAAN,aAAA,uBAAbA,aAAA,CAAeO,KAAK;EAErC,MAAMC,MAAM,GAAIH,QAAQ,IAAIJ,cAAc,CAACI,QAAQ,CAAC,IAAK,EAAE;EAC3D,OAAOG,MAAM,CAACC,MAAM,GAAG,CAAC,IAAID,MAAM,CAACE,KAAK,CAAEC,KAAK,IAAKjB,IAAI,IAAIiB,KAAK,IAAIjB,IAAI,CAAC;AAC5E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}